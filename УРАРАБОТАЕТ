from machine import deepsleep
import time
import bluetooth
import struct
import micropython

ble = bluetooth.BLE()

# --- Глобальные ---
connected = False
conn_handle = None

hrs_value_handle = None   # 0x2A37
pox_value_handle = None   # 0x2A5F

already_scheduled = False

# --- Настройки ---
SLEEP_BETWEEN_MEAS_MS = 60_000   # 60 секунд сна
ADV_INTERVAL_US       = 100_000  # 100 мс реклама


# ---------- SFLOAT (IEEE 11073) ----------
def encode_sfloat(value):
    if value < 0:
        value = 0
    if value > 2047:
        value = 2047
    mantissa = int(value) & 0x0FFF
    exponent = 0
    raw = ((exponent & 0x0F) << 12) | mantissa
    return struct.pack('<H', raw)


def ble_irq(event, data):
    global connected, conn_handle, already_scheduled

    print("BLE Event:", event, "data:", data)

    if event == 1:  # CONNECT
        conn_handle_local, addr_type, addr = data
        conn_handle = conn_handle_local
        connected = True
        already_scheduled = False
        print("Connected:", conn_handle)

        # Планируем отправку после задержки
        micropython.schedule(_scheduled_send, 0)

    elif event == 2:  # DISCONNECT
        conn, addr_type, addr = data
        connected = False
        print("Disconnected")


def start_advertising():
    name = "ESP32-OXI"
    name_bytes = name.encode()

    flags = bytearray([2, 0x01, 0x06])
    name_ad = bytearray([len(name_bytes) + 1, 0x09]) + name_bytes

    service_uuids_ad = bytearray([
        5,
        0x03,
        0x0D, 0x18,
        0x22, 0x18
    ])

    appearance_ad = bytearray([
        3,
        0x19,
        0x40, 0x0C
    ])

    adv_payload = flags + name_ad + service_uuids_ad + appearance_ad
    ble.gap_advertise(ADV_INTERVAL_US, adv_payload)
    print("Advertising as", name)


def init_ble():
    global hrs_value_handle, pox_value_handle
    global connected, conn_handle, already_scheduled

    connected = False
    conn_handle = None
    already_scheduled = False

    ble.active(True)
    ble.irq(ble_irq)

    HRS_SERVICE_UUID = bluetooth.UUID(0x180D)
    HRS_MEAS_UUID    = bluetooth.UUID(0x2A37)

    PULSEOX_SERVICE_UUID = bluetooth.UUID(0x1822)
    PULSEOX_MEAS_UUID    = bluetooth.UUID(0x2A5F)

    CHAR_FLAGS = bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY

    services = (
        (HRS_SERVICE_UUID, (
            (HRS_MEAS_UUID, CHAR_FLAGS),
        )),
        (PULSEOX_SERVICE_UUID, (
            (PULSEOX_MEAS_UUID, CHAR_FLAGS),
        )),
    )

    ((hrs_value_handle,), (pox_value_handle,)) = ble.gatts_register_services(services)

    print("HRS handle:", hrs_value_handle)
    print("PLX handle:", pox_value_handle)

    start_advertising()


def _scheduled_send(_):
    global already_scheduled

    if already_scheduled:
        return
    already_scheduled = True

    # --- ВОТ ТУТ ВАЖНАЯ ЗАДЕРЖКА ---
    print("Waiting 4 seconds before sending packet...")
    time.sleep(4)   # ← задержка 4 сек, можно изменить на 3 при желании

    if connected and conn_handle is not None:
        hr = 72
        spo2 = 97
        send_hr_spo2_once(hr, spo2)
        print(f"Sent 1 packet → HR={hr}, SpO2={spo2}")
    else:
        print("No connection, skip send")

    try:
        if conn_handle is not None:
            print("Disconnecting...")
            ble.gap_disconnect(conn_handle)
            time.sleep_ms(200)
    except:
        pass

    try:
        ble.active(False)
    except:
        pass

    print("Deep sleep", SLEEP_BETWEEN_MEAS_MS, "ms")
    deepsleep(SLEEP_BETWEEN_MEAS_MS)


def send_hr_spo2_once(hr, spo2):
    global conn_handle, connected, hrs_value_handle, pox_value_handle

    if not connected or conn_handle is None:
        return

    hr_flags = 0x00
    hrs_payload = struct.pack("<BB", hr_flags, hr)

    try:
        ble.gatts_notify(conn_handle, hrs_value_handle, hrs_payload)
    except OSError as e:
        print("HRS notify error:", e)

    plx_flags = 0x00
    spo2_sfloat = encode_sfloat(spo2)
    pr_sfloat = encode_sfloat(hr)
    pox_payload = struct.pack("<B", plx_flags) + spo2_sfloat + pr_sfloat

    try:
        ble.gatts_notify(conn_handle, pox_value_handle, pox_payload)
    except OSError as e:
        print("PLX notify error:", e)


def main():
    print("Boot, init BLE...")
    init_ble()

    while True:
        time.sleep_ms(200)


main()
